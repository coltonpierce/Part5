C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE PLAY_SONG
OBJECT MODULE PLACED IN Play_Song.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Play_Song.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "stdio.h"
   2          #include "main.h"
   3          #include "PORT.H"
   4          #include "SPI.h"
   5          #include "File_System_v2.h"
   6          #include "Read_Sector.h"
   7          #include "Play_Song.h"
   8          #include "SDCard.h"
   9          extern uint8_t xdata buf1[512];
  10          extern uint8_t xdata buf2[512]; 
  11          ///*
  12          uint8_t idata state_g, play_status, temp8;
  13          uint16_t idata index1_g, index2_g;
  14          uint32_t idata sector_offset, sector, cluster_g;
  15          
  16          void Play_Song(uint32_t Start_Cluster)
  17          {
  18   1        printf("Starting Cluster = %lu\n\r",Start_Cluster);
  19   1      
  20   1        sector=First_Sector(Start_Cluster);
  21   1        printf("Starting Sector = %lu\n\r",sector);
  22   1        sector_offset=0;
  23   1      
  24   1        index1_g=0;
  25   1        Read_Sector(sector+sector_offset, 512, buf1);
  26   1      
  27   1        sector_offset++;
  28   1        index2_g=0;
  29   1         
  30   1        Read_Sector(sector+sector_offset, 512, buf2);
  31   1        
  32   1        sector_offset++;
  33   1        
  34   1        cluster_g = Start_Cluster;
  35   1        state_g = DATA_SEND_1;
  36   1        play_status = 1;
  37   1        TH2 = TIMER2H;
  38   1        RCAP2H = TIMER2H;
  39   1        TL2 = TIMER2L;
  40   1        RCAP2L = TIMER2L;
  41   1        TF0 = 0;
  42   1        T2CON = 0x00;
  43   1        TMOD |= 0x01;
  44   1        ET2 = 1;
  45   1        EA = 1;
  46   1        
  47   1        TR2 = 1;
  48   1        while(play_status != 0 && SW3 == 1)
  49   1        {
  50   2          PCON |= 0x01;
  51   2        }
  52   1        
  53   1        TR2 = 0;
  54   1        
  55   1        
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 2   

  56   1      }
  57            
  58            
  59          void timer2 (void) interrupt 5
  60          { 
  61   1        
  62   1        TR0 = 0;
  63   1        TH0 = TIMER0H;
  64   1        TL0 = TIMER0L;
  65   1        TF0 = 0;
  66   1        TR0 = 1;
  67   1        
  68   1        
  69   1          if(SW1 == 0 && state_g == PAUSE)  // Play
  70   1        {
  71   2          state_g = temp8;
  72   2        }
  73   1        if(SW2 == 0 && state_g != PAUSE) // Pause
  74   1        {
  75   2          temp8 = state_g;
  76   2          state_g = PAUSE;
  77   2        }
  78   1        
  79   1        
  80   1        if(state_g == LOAD_BUFFER_1)
  81   1        {
  82   2          if(sector_offset >= 64)
  83   2          {
  84   3            state_g = FIND_CLUSTER_1;
  85   3          }
  86   2        }
  87   1      
  88   1        if(state_g == LOAD_BUFFER_2)
  89   1        {
  90   2          if(sector_offset >= 64)
  91   2          {
  92   3            state_g = FIND_CLUSTER_2;
  93   3          }
  94   2        }
  95   1      
  96   1      
  97   1        switch(state_g)
  98   1        {
  99   2          // Data Send 1
 100   2          case DATA_SEND_1:
 101   2          {
 102   3            LED1 = 0;
 103   3            LED2 = 1;
 104   3            LED3 = 1;
 105   3            LED4 = 1;
 106   3            while((DATA_REQ == ACTIVE) && (TF0 == 0))                 
 107   3            {
 108   4              BIT_EN = 1;
 109   4              SPI_Transfer_ISR(buf1[index1_g], & temp8);              
 110   4              index1_g++;                                               
 111   4              if(index1_g > 511) // Buffer 1 empty
 112   4              {
 113   5                if(index2_g >511)
 114   5                {
 115   6                  if(play_status == 3)                                  
 116   6                  {
 117   7                    play_status = 0;
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 3   

 118   7                  }
 119   6                  else
 120   6                  {
 121   7                    state_g = LOAD_BUFFER_2; // Buff 2 and Buff 1 empty
 122   7                  }
 123   6                }                                                       
 124   5                else
 125   5                {
 126   6                  state_g = DATA_SEND_2; // BUFF 1 empty                //Seems like this is when buffer 1 still has stuff
 127   6                }
 128   5                TF0 = 1;
 129   5              }       // What does this do? is this the interupt for the whole system to keep pace
 130   4              BIT_EN = 0;
 131   4            }
 132   3            if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_1))
 133   3            {
 134   4              
 135   4              if(index2_g > 511) // Buffer 2 is empty
 136   4              {
 137   5                state_g = LOAD_BUFFER_2; // DR inactive and BUFF 2 empty
 138   5              }
 139   4              else
 140   4              {
 141   5                //state_g = DATA_SEND_1;
 142   5                state_g = DATA_IDLE_1; // DR interupt
 143   5              }
 144   4            }
 145   3            
 146   3            break;
 147   3          }
 148   2          
 149   2          //Load Buffer 1
 150   2          case LOAD_BUFFER_1:
 151   2          {
 152   3            LED1 = 1;
 153   3            LED2 = 1;
 154   3            LED3 = 0;
 155   3            LED4 = 1;
 156   3            //printf("LOAD_BUFFER_1\n\r");
 157   3            Read_Sector_ISR(sector+sector_offset, 512, buf1);
 158   3            //printf("%8.8lX", sector);
 159   3            sector_offset++;
 160   3            //state_g = DATA_SEND_2;
 161   3            state_g = DATA_IDLE_2;
 162   3            index1_g = 0;
 163   3            
 164   3            break;
 165   3          }
 166   2          
 167   2          // Find Cluster 1
 168   2          case FIND_CLUSTER_1:
 169   2          {
 170   3            LED1 = 1;
 171   3            LED2 = 1;
 172   3            LED3 = 1;
 173   3            LED4 = 0;
 174   3            //printf("FIND_CLUSTER_1\n\r");
 175   3            cluster_g = Find_Next_Clus_ISR(cluster_g, buf1);
 176   3            if(cluster_g == 0x0FFFFFFF) // Last cluster
 177   3            {
 178   4              //printf("DONE\n\r");
 179   4              play_status = 3;
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 4   

 180   4              //state_g = DATA_SEND_2;
 181   4              state_g = DATA_IDLE_2;
 182   4            }
 183   3            else
 184   3            {
 185   4              sector = First_Sector_ISR(cluster_g);
 186   4              sector_offset = 0;
 187   4              //state_g = DATA_SEND_2;
 188   4              state_g = DATA_IDLE_2;
 189   4            }
 190   3            break;
 191   3          }
 192   2          
 193   2          case DATA_IDLE_1:
 194   2          {
 195   3            LED1 = 1;
 196   3            LED2 = 1;
 197   3            LED3 = 1;
 198   3            LED4 = 1;
 199   3            //printf("DATA_IDLE_1\n\r");
 200   3            if(DATA_REQ == ACTIVE)
 201   3            {
 202   4              state_g = DATA_SEND_1;
 203   4            }
 204   3            break;
 205   3          }
 206   2              
 207   2          // Data Send 2
 208   2          case DATA_SEND_2:
 209   2          {
 210   3            LED1 = 1;
 211   3            LED2 = 0;
 212   3            LED3 = 1;
 213   3            LED4 = 1;
 214   3            //printf("DATA_SEND_2\n\r");
 215   3            
 216   3            while((DATA_REQ == ACTIVE) && (TF0 == 0))                 // Can DATA_REQ go inactive while in the loop
 217   3            {
 218   4              BIT_EN = 1;
 219   4              SPI_Transfer_ISR(buf2[index2_g], & temp8);              // What is temp8
 220   4              index2_g++;
 221   4              if(index2_g > 511) // Buffer 2 empty
 222   4              {
 223   5                if(index1_g > 511) // Buffer 1 empty
 224   5                {
 225   6                  if(play_status == 3)                                  // Works only if after FIND_CLUSTER. why?
 226   6                  {
 227   7                    play_status = 0;
 228   7                  }
 229   6                  else
 230   6                  {
 231   7                    state_g = LOAD_BUFFER_1; // Buff 1 and Buff 2 empty
 232   7                  }
 233   6                }                                                       // No FIND_CLUSTER
 234   5                else
 235   5                {
 236   6                  state_g = DATA_SEND_1; // BUFF 2 empty                //Seems like this is when buffer 2 still has stuff
 237   6                }
 238   5                TF0 = 1;                                                // What does this do? is this the interupt for the whole system to ke
             -ep pace
 239   5              }
 240   4              BIT_EN = 0;
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 5   

 241   4            }
 242   3            if((DATA_REQ == INACTIVE) && (state_g == DATA_SEND_2))
 243   3            {
 244   4              //printf("INACTIVE 2\n\r");
 245   4              if(index1_g > 511) // Buffer 1 is empty
 246   4              {
 247   5                state_g = LOAD_BUFFER_1; // DR inactive and BUFF 1 empty
 248   5              }
 249   4              else
 250   4              {
 251   5                //state_g = DATA_SEND_2;
 252   5                state_g = DATA_IDLE_2; // DR interupt
 253   5              }
 254   4            }
 255   3            
 256   3            
 257   3            break;
 258   3          }
 259   2          
 260   2          //Load Buffer 2
 261   2          case LOAD_BUFFER_2:
 262   2          {
 263   3            LED1 = 1;
 264   3        LED2 = 1;
 265   3        LED3 = 0;
 266   3        LED4 = 1;
 267   3            //printf("LOAD_BUFFER_2\n\r");
 268   3            Read_Sector_ISR(sector+sector_offset, 512, buf2);
 269   3            sector_offset++;
 270   3            //state_g = DATA_SEND_1;
 271   3            state_g = DATA_IDLE_1;
 272   3            index2_g = 0;
 273   3            break;
 274   3          }
 275   2          
 276   2          // Find Cluster 2
 277   2          case FIND_CLUSTER_2:
 278   2          {
 279   3            LED1 = 1;
 280   3        LED2 = 1;
 281   3        LED3 = 1;
 282   3        LED4 = 0;
 283   3            //printf("FIND_CLUSTER_2\n\r");
 284   3            cluster_g = Find_Next_Clus_ISR(cluster_g, buf2);
 285   3            if(cluster_g == 0x0FFFFFFF)
 286   3            {
 287   4              play_status = 3;
 288   4              //state_g = DATA_SEND_1;
 289   4              state_g = DATA_IDLE_1;
 290   4            }
 291   3            else
 292   3            {
 293   4              sector = First_Sector_ISR(cluster_g);
 294   4              sector_offset = 0;
 295   4              //state_g = DATA_SEND_1;
 296   4              state_g = DATA_IDLE_1;
 297   4            }
 298   3            break;
 299   3          }
 300   2          
 301   2          case DATA_IDLE_2:
 302   2          {
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 6   

 303   3            LED1 = 1;
 304   3        LED2 = 1;
 305   3        LED3 = 1;
 306   3        LED4 = 1;
 307   3            //printf("DATA_IDLE_2\n\r");
 308   3            if(DATA_REQ == ACTIVE)
 309   3            {
 310   4              state_g = DATA_SEND_2;
 311   4            }
 312   3            break;
 313   3          }
 314   2          case PAUSE:
 315   2          {
 316   3            //printf("%2.2bX", temp8);
 317   3            break;
 318   3          }
 319   2        }
 320   1        //trig = 1;
 321   1        TF2 = 0;
 322   1      }
 323          
 324            
 325            
 326            
 327            
 328            
 329            
 330          
 331            
 332          //   uint8_t buffer1, buffer2, temp8;
 333          //   
 334          //   AMBERLED=OFF;
 335          //   do
 336          //  {      
 337          //     do
 338          //     {
 339          //        if(DATA_REQ==0)
 340          //        {
 341          //           GREENLED=ON;
 342          //           BIT_EN=1;
 343          //           SPI_Transfer(buf1[index1], &temp8);
 344          //         GREENLED=OFF;
 345          //         index1++;
 346          //           if(index1>511)
 347          //           {
 348          //              if(index2>511)
 349          //              {
 350          //                  BIT_EN=0;              
 351          //                  AMBERLED=ON;
 352          //          index2=0;
 353          //          
 354          //          Read_Sector(sector+sector_offset, 512, buf2);
 355          //          sector_offset++;
 356          //                  AMBERLED=OFF;
 357          //              }
 358          //              buffer1=0;
 359          //              buffer2=1;
 360          
 361          //          }
 362          //       }
 363          //       else
 364          //       {
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 7   

 365          //          if(index2>511)
 366          //          {
 367          //              BIT_EN=0;
 368          //              AMBERLED=ON;
 369          //        index2=0;
 370          //        
 371          //        Read_Sector(sector+sector_offset, 512, buf2);
 372          //        sector_offset++;
 373          //              AMBERLED=OFF;
 374          //          }
 375          //          else
 376          //          {
 377          //              if(index1>511)
 378          //              {
 379          //                  buffer1=0;
 380          //                  buffer2=1;
 381          //              }
 382          //          }
 383          //      }
 384          //   }while(buffer1==1);
 385          //   do
 386          //   {
 387          //      if(DATA_REQ==0)
 388          //      {
 389          //          REDLED=ON;
 390          //          BIT_EN=1;
 391          //          SPI_Transfer(buf2[index2], &temp8);
 392          //          REDLED=OFF;
 393          //          index2++;
 394          //          if(index2>511)
 395          //          {
 396          //              if(index1>511)
 397          //              {
 398          //                  BIT_EN=0; 
 399          //                  YELLOWLED=ON;
 400          //          index1=0;
 401          //          
 402          //          Read_Sector(sector+sector_offset, 512, buf1);
 403          //          sector_offset++;
 404          //                  YELLOWLED=OFF;
 405          //              }
 406          //              buffer2=0;
 407          //              buffer1=1;
 408          //         
 409          //           }
 410          //        }
 411          //        else
 412          //        {
 413          //           if(index1>511)
 414          //           {
 415          //              BIT_EN=0; 
 416          //              YELLOWLED=ON;
 417          //        index1=0;
 418          //        
 419          //        Read_Sector(sector+sector_offset, 512, buf1);
 420          //        sector_offset++;
 421          //              YELLOWLED=OFF;
 422          //           }
 423          //           else
 424          //           {
 425          //               if(index2>511)
 426          //               {
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 8   

 427          //                  buffer2=0;
 428          //                  buffer1=1;
 429          //               }
 430          //           }
 431          //        }
 432          //      }while(buffer2==1);
 433          //  }while(sector_offset<512);
 434          ////P3_2=OFF;
 435          //} 
 436          
 437          
 438          
 439          
 440          
 441          
 442          //*/
 443          /*
 444          
 445          void Play_Song2(uint32_t Start_Cluster)
 446          {
 447             uint16_t index1;
 448             uint8_t buff_emp, * p_out;
 449             uint32_t sector, sector_offset;
 450          printf("Starting Cluster = %lu\n\r",Start_Cluster);
 451          sector=First_Sector(Start_Cluster);
 452          printf("Starting Sector = %lu\n\r",sector);
 453          //P3_2=ON;
 454          sector_offset=0;
 455          YELLOWLED=ON;
 456          nCS0=0;
 457          SEND_COMMAND(17,sector+sector_offset);
 458          read_block(512,buf1);
 459          index1=0;
 460          sector_offset++;
 461          nCS0=1;
 462          YELLOWLED=OFF;
 463          //AMBERLED=ON;
 464          //nCS0=0;
 465          //SEND_COMMAND(17,sector+sector_offset);
 466          //read_block(buf2,512);
 467          //sector_offset++;
 468          //nCS0=1;
 469          //AMBERLED=OFF;
 470          
 471          
 472             p_out=buf1;
 473             buff_emp=0;
 474             do
 475             {
 476                if(DATA_REQ==0)
 477                {
 478                   GREENLED=ON;
 479                   BIT_EN=1;
 480                   while((SPSTA&0x80)!=0x80);
 481                   SPDAT=*(buf1+index1);
 482                   index1++;
 483                   if(index1==512)
 484                   {
 485                      buff_emp|=1;           
 486                   }
 487               if(index1==1024)
 488               {
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 9   

 489                  index1=0;
 490                buff_emp|=2;
 491                 }
 492                   if(index1==768)
 493                   {
 494                     BIT_EN=0;
 495                     GREENLED=OFF;
 496                     if((buff_emp & 0x01)==0x01)
 497                     {
 498                        YELLOWLED=ON;
 499                        nCS0=0;
 500                        SEND_COMMAND(17,sector+sector_offset);
 501                        read_block(512,buf1);
 502                        nCS0=1;             
 503                        YELLOWLED=OFF;
 504                        buff_emp &= 0xFE;
 505                        sector_offset++;            
 506                     }
 507                   }
 508                   if(index1==256)
 509                   {
 510                     BIT_EN=0;
 511                     GREENLED=OFF;
 512                     if((buff_emp & 0x02)==0x02)
 513                     {
 514                        AMBERLED=ON;
 515                        nCS0=0;
 516                        SEND_COMMAND(17,sector+sector_offset);
 517                        read_block(512,buf2);
 518                        nCS0=1;             
 519                        AMBERLED=OFF;
 520                        buff_emp &= 0xFD;
 521                        sector_offset++;            
 522                     }
 523                   }                        
 524                 }
 525                 else
 526                 {
 527                    GREENLED=OFF;
 528                    BIT_EN=0;
 529                    if((buff_emp & 0x01)==0x01)
 530                    {
 531                       YELLOWLED=ON;
 532                       nCS0=0;
 533                       SEND_COMMAND(17,sector+sector_offset);
 534                       read_block(512,buf1);
 535                       nCS0=1;             
 536                       YELLOWLED=OFF;
 537                       buff_emp &= 0xFE;
 538                       sector_offset++;
 539           //            print_hex(1);
 540           //            print_hex(i);
 541                      
 542                    }
 543                    else if((buff_emp & 0x02)==0x02)
 544                    {
 545                       AMBERLED=ON;
 546                       nCS0=0;
 547                       SEND_COMMAND(17,sector+sector_offset);
 548                       read_block(512,buf2);
 549                       nCS0=1;             
 550                       AMBERLED=OFF;
C51 COMPILER V9.53.0.0   PLAY_SONG                                                         12/15/2015 16:32:03 PAGE 10  

 551                       buff_emp &= 0xFD;
 552                       sector_offset++;
 553                    }
 554                 }
 555             }while(sector_offset<128);   
 556             GREENLED=1;
 557          //   P3_2=OFF;
 558            }  
 559          
 560           */  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1111    ----
   CONSTANT SIZE    =     49    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =     19    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
