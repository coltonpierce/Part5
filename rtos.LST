C51 COMPILER V9.53.0.0   RTOS                                                              12/15/2015 10:00:53 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE RTOS
OBJECT MODULE PLACED IN rtos.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE rtos.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "main.h"
   2          #include "PORT.H"
   3          #include "stdio.h"
   4          #include "UART.h"
   5          #include "SPI.h"
   6          #include "SDcard.h"
   7          #include "Long_Serial_In.h"
   8          #include "File_System_v2.h"
   9          #include "STA013_Config.h"
  10          #include "Directory_Functions_struct.h"
  11          #include "rtos.h"
  12          
  13          
  14          
  15          
  16          //void rtos_init(void)
  17          //{
  18          //  uint16 reload;
  19          //  uint8 reloadHigh;
  20          //  uint8 reloadLow;
  21          //  
  22          //  // Arrays from config.asm and other MP3 variables
  23          //  extern code uint8* CONFIG;
  24          //  extern code uint8* CONFIG2;
  25          //  uint8 code* configPtr;
  26          //  uint8 idata temp[2] = {0x01};
  27          //  uint8 i;
  28          //  uint8 error = 0;
  29          //  
  30          //  // Tick rate (1 ms)
  31          //  reload = (uint16)(65536UL - (uint32)TICK_MS * (OSC_FREQ/1000) / (uint32)OSC_PER_INST);
  32          //  reloadHigh = (uint8)(reload / 256);
  33          //  reloadLow = (uint8)(reload % 256);
  34          //  
  35          //  // X2 Mode
  36          //  CKCON0 = 0x01;
  37          //  CKCON1 = 0x00;
  38          //  
  39          //  // XRAM Size
  40          //  AUXR = 0x0D;
  41          //  
  42          //  // Init timer2
  43          //  T2CON = 0x04;
  44          //  TH2 = reloadHigh;
  45          //  RCAP2H = reloadHigh;
  46          //  TL2 = reloadLow;
  47          //  RCAP2L = reloadLow;
  48          //  
  49          //  IPH0 &= 0xDF; // Priority 1
  50          //  IPL0 |= 0x20;
  51          //  ET2 = 1;
  52          //  TR2 = 1;
  53          //  
  54          //  uart_init();
  55          //  spi_sdcard_init();
C51 COMPILER V9.53.0.0   RTOS                                                              12/15/2015 10:00:53 PAGE 2   

  56          //  fs_init();
  57          //  
  58          //  // Reset MP3
  59          //  mp3_reset = 0;
  60          //  for(i=0; i<80; i++);
  61          //  mp3_reset = 1;
  62          //  
  63          //  // Test TWI
  64          //  do
  65          //  {
  66          //    error = twi_write(0x43, 1, temp); 
  67          //  } while(error != 0);
  68          //  do
  69          //  {
  70          //    error = twi_read(0x43, 1, temp);
  71          //  } while(error != 0);
  72          //  if(temp[0] != 0xAC)
  73          //    redLED = 0;
  74          //  
  75          //  // Send STAO13 config file
  76          //  configPtr = CONFIG;
  77          //  while(*configPtr != 0xFF)
  78          //  {
  79          //    temp[0] = *configPtr;
  80          //    configPtr++;
  81          //    temp[1] = *configPtr;
  82          //    configPtr++;
  83          //    error = twi_write(0x43, 2, temp);
  84          //  }
  85          //  
  86          //  // Pause
  87          //  for(i=0; i<80; ++i);
  88          //  
  89          //  // Send second STAO13 config
  90          //  configPtr = CONFIG2;
  91          //  while(*configPtr != 0xFF)
  92          //  {
  93          //    temp[0] = *configPtr;
  94          //    configPtr++;
  95          //    temp[1] = *configPtr;
  96          //    configPtr++;
  97          //    error = twi_write(0x43, 2, temp);
  98          //  }
  99          //  
 100          //  startCluster = fs_findMP3(2);
 101          //  
 102          //  rtos_state = RTOS_CHECK_MEM;
 103          //}
 104          
 105          //void rtos_spin()
 106          //{
 107          //  bit spin = 1;
 108          //  
 109          //  EA = 1;
 110          //  
 111          //  while(spin)
 112          //  {
 113          //    // Sleep until next interrupt
 114          //    PCON |= 0x01;
 115          //  }
 116          //}
 117          
C51 COMPILER V9.53.0.0   RTOS                                                              12/15/2015 10:00:53 PAGE 3   

 118          //void rtos_tick_ISR(void) interrupt 5 using 3
 119          //{
 120          //  static bit song = 0;
 121          //  static bit buf1 = 0;
 122          //  static bit buf2 = 0;
 123          //  static bit cluster = 0;
 124          //  static bit currentBuf = 0;
 125          //  static uint32 clusterNum = 0UL;
 126          //  static uint8 relativeSector = 0;
 127          //  static uint16 currentByte = 0;
 128          //  
 129          //  extern uint8 xdata* fs_buffer;
 130          //  
 131          //  TF2 = 0;
 132          //  
 133          //  if(clusterNum == 0UL)
 134          //  {
 135          //    clusterNum = startCluster;
 136          //    cluster = 1;
 137          //  }
 138          //  
 139          //  switch(rtos_state)
 140          //  {
 141          //  case RTOS_SEND_DATA:
 142          //    fs_setBuffer(currentBuf);
 143          //    while(mp3_data_req && (buf1 || buf2))
 144          //    {
 145          //      spi_mp3_data(1, fs_buffer + currentByte);
 146          //      currentByte++;
 147          //      if(currentByte == 512)
 148          //      {
 149          //        // Buffer empty, swap
 150          //        if(currentBuf)
 151          //          buf2 = 0;
 152          //        else
 153          //          buf1 = 0;
 154          //        currentBuf = ~currentBuf;
 155          //        fs_setBuffer(currentBuf);
 156          //        currentByte = 0;
 157          //      }
 158          //    }
 159          //    if(mp3_data_req == 0)
 160          //    {
 161          //      redLED=~redLED;
 162          //      song = 1;
 163          //    }
 164          //    rtos_state = RTOS_CHECK_MEM;
 165          //    break;
 166          //  
 167          //  case RTOS_CHECK_MEM:
 168          //    if(buf1 == 0 || buf2 == 0)
 169          //    {
 170          //      if(relativeSector == 64)
 171          //      {
 172          //        rtos_state = RTOS_NEXT_CLUS;
 173          //        cluster = 0;
 174          //      }
 175          //      else
 176          //        rtos_state = RTOS_READ_SEC;
 177          //    }
 178          //    else 
 179          //      rtos_state = RTOS_SEND_DATA;
C51 COMPILER V9.53.0.0   RTOS                                                              12/15/2015 10:00:53 PAGE 4   

 180          //    break;
 181          //  
 182          //  case RTOS_READ_SEC:
 183          //    if(buf1 == 0 || buf2 == 0)
 184          //    {
 185          //      if(buf1 == 0)
 186          //      {
 187          //        fs_setBuffer(0);
 188          //        buf1 = 1;
 189          //      }
 190          //      else
 191          //      {
 192          //        fs_setBuffer(1);
 193          //        buf2 = 1;
 194          //      }
 195          //      
 196          //      fs_loadSector(clusterNum, relativeSector);
 197          //      relativeSector++;
 198          //    }
 199          //    
 200          //    rtos_state = RTOS_SEND_DATA;
 201          //    break;
 202          //  
 203          //  case RTOS_NEXT_CLUS:
 204          //    clusterNum = fs_FATentry(clusterNum);
 205          //    relativeSector = 0;
 206          //    if(fs_FATeof(clusterNum))
 207          //    {
 208          //      song = 0;
 209          //      EA = 0; //TODO new song, find start cluster
 210          //    }
 211          //    else
 212          //      cluster = 1;
 213          //    
 214          //    if(song)
 215          //      rtos_state = RTOS_SEND_DATA;
 216          //    else
 217          //      rtos_state = RTOS_READ_SEC;
 218          //    break;
 219          //  
 220          //  default:
 221          //    rtos_state = RTOS_SEND_DATA;
 222          //    break;
 223          //  }
 224          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
