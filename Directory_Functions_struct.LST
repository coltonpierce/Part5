C51 COMPILER V9.53.0.0   DIRECTORY_FUNCTIONS_STRUCT                                        12/15/2015 16:41:45 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE DIRECTORY_FUNCTIONS_STRUCT
OBJECT MODULE PLACED IN Directory_Functions_struct.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Directory_Functions_struct.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND
                    - TABS(2)

line level    source

   1          #include "AT89C51RC2.h"
   2          #include <stdio.h>
   3          #include "main.h"
   4          #include "PORT.H"
   5          #include "UART.h"
   6          #include "SPI.h"
   7          #include "SDCard.h"
   8          #include "File_System.h"
   9          #include "print_bytes.h"
  10          #include "Directory_Functions_struct.h"
  11          #include "Read_Sector.h"
  12          
  13          
  14          
  15          FS_values_t idata Drive_values;
  16          
  17          /***********************************************************************
  18          DESC: Returns a pointer to the global structure Drive_values to export to other files
  19          INPUT: void
  20          RETURNS: Pointer to the structure Drive_values
  21          CAUTION: 
  22          ************************************************************************/
  23          
  24          FS_values_t * Export_Drive_values(void)
  25          {
  26   1         return &Drive_values;
  27   1      }
  28          
  29          FS_values_t * Export_Drive_values_ISR(void)
  30          {
  31   1         return &Drive_values;
  32   1      }
  33          
  34          
  35          /***********************************************************************
  36          DESC: Prints all short file name entries for a given directory 
  37          INPUT: Starting Sector of the directory and the pointer to a 
  38          block of memory in xdata that can be used to read blocks from the SD card
  39          RETURNS: uint16_t number of entries found in the directory
  40          CAUTION: Supports FAT16, SD_shift must be set before using this function
  41          ************************************************************************/
  42          
  43          
  44          
  45          uint16_t  Print_Directory(uint32_t Sector_num, uint8_t xdata * array_in)
  46          { 
  47   1         uint32_t idata Sector, max_sectors;
  48   1         uint16_t idata i, entries;
  49   1         uint8_t idata temp8, j, attr, out_val, error_flag;
  50   1         uint8_t * values;
  51   1      
  52   1      
  53   1         values=array_in;
  54   1         entries=0;
C51 COMPILER V9.53.0.0   DIRECTORY_FUNCTIONS_STRUCT                                        12/15/2015 16:41:45 PAGE 2   

  55   1         i=0;
  56   1         if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
  57   1         { 
  58   2            max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
  59   2         }
  60   1         else
  61   1         {
  62   2            max_sectors=Drive_values.SecPerClus;
  63   2         }
  64   1         Sector=Sector_num;
  65   1         error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
  66   1         if(error_flag==no_errors)
  67   1         {
  68   2           do
  69   2           {
  70   3              temp8=read8(0+i,values);  // read first byte to see if empty
  71   3              if((temp8!=0xE5)&&(temp8!=0x00))
  72   3            {  
  73   4               attr=read8(0x0b+i,values);
  74   4             if((attr&0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
  75   4             {
  76   5                entries++;
  77   5              printf("%5d. ",entries);  // print entry number with a fixed width specifier
  78   5                for(j=0;j<8;j++)
  79   5              {
  80   6                 out_val=read8(i+j,values);   // print the 8 byte name
  81   6                 putchar(out_val);
  82   6              }
  83   5                    if((attr&0x10)==0x10)  // indicates directory
  84   5              {
  85   6                 for(j=8;j<11;j++)
  86   6                 {
  87   7                    out_val=read8(i+j,values);
  88   7                    putchar(out_val);
  89   7                 }
  90   6                 printf("[DIR]\n");
  91   6              }
  92   5              else       // print a period and the three byte extension for a file
  93   5              {
  94   6                 putchar(0x2E);       
  95   6                 for(j=8;j<11;j++)
  96   6                 {
  97   7                    out_val=read8(i+j,values);
  98   7                    putchar(out_val);
  99   7                 }
 100   6                 putchar(0x0d);
 101   6                       putchar(0x0a);
 102   6              }
 103   5              }
 104   4          }
 105   3              i=i+32;  // next entry
 106   3              if(i>510)
 107   3              {
 108   4              Sector++;
 109   4                    if((Sector-Sector_num)<max_sectors)
 110   4              {
 111   5                       error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 112   5                 if(error_flag!=no_errors)
 113   5                 {
 114   6                    entries=0;   // no entries found indicates disk read error
 115   6                  temp8=0;     // forces a function exit
 116   6                 }
C51 COMPILER V9.53.0.0   DIRECTORY_FUNCTIONS_STRUCT                                        12/15/2015 16:41:45 PAGE 3   

 117   5                       i=0;
 118   5              }
 119   4              else
 120   4              {
 121   5                 entries=entries|more_entries;  // set msb to indicate more entries in another cluster
 122   5                 temp8=0;                       // forces a function exit
 123   5              }
 124   4              }
 125   3               
 126   3          }while(temp8!=0);
 127   2        }
 128   1        else
 129   1        {
 130   2           entries=0;    // no entries found indicates disk read error
 131   2        }
 132   1         return entries;
 133   1       }
 134          
 135          
 136          /***********************************************************************
 137          DESC: Uses the same method as Print_Directory to locate short file names,
 138                but locates a specified entry and returns and cluster  
 139          INPUT: Starting Sector of the directory, an entry number and a pointer to a 
 140          block of memory in xdata that can be used to read blocks from the SD card
 141          RETURNS: uint32_t with cluster in lower 28 bits.  Bit 28 set if this is 
 142                   a directory entry, clear for a file.  Bit 31 set for error.
 143          CAUTION: 
 144          ************************************************************************/
 145          
 146          uint32_t Read_Dir_Entry(uint32_t Sector_num, uint16_t Entry, uint8_t xdata * array_in)
 147          { 
 148   1         uint32_t Sector, max_sectors, return_clus;
 149   1         uint16_t i, entries;
 150   1         uint8_t temp8, attr, error_flag;
 151   1         uint8_t * values;
 152   1      
 153   1         values=array_in;
 154   1         entries=0;
 155   1         i=0;
 156   1         return_clus=0;
 157   1         if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 158   1         { 
 159   2            max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 160   2         }
 161   1         else
 162   1         {
 163   2            max_sectors=Drive_values.SecPerClus;
 164   2         }
 165   1         Sector=Sector_num;
 166   1         error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 167   1         if(error_flag==no_errors)
 168   1         {
 169   2           do
 170   2           {
 171   3              temp8=read8(0+i,values);  // read first byte to see if empty
 172   3              if((temp8!=0xE5)&&(temp8!=0x00))
 173   3            {  
 174   4               attr=read8(0x0b+i,values);
 175   4             if((attr&0x0E)==0)    // if hidden do not print
 176   4             {
 177   5                entries++;
 178   5                    if(entries==Entry)
C51 COMPILER V9.53.0.0   DIRECTORY_FUNCTIONS_STRUCT                                        12/15/2015 16:41:45 PAGE 4   

 179   5                    {
 180   6                if(Drive_values.FATtype==FAT32)
 181   6                      {
 182   7                         return_clus=read8(21+i,values);
 183   7                 return_clus=return_clus<<8;
 184   7                         return_clus|=read8(20+i,values);
 185   7                         return_clus=return_clus<<8;
 186   7                      }
 187   6                      return_clus|=read8(27+i,values);
 188   6                return_clus=return_clus<<8;
 189   6                      return_clus|=read8(26+i,values);
 190   6                attr=read8(0x0b+i,values);
 191   6                if(attr&0x10) return_clus|=directory_bit;
 192   6                      temp8=0;    // forces a function exit
 193   6                    }
 194   5                    
 195   5              }
 196   4          }
 197   3              i=i+32;  // next entry
 198   3              if(i>510)
 199   3              {
 200   4              Sector++;
 201   4              if((Sector-Sector_num)<max_sectors)
 202   4              {
 203   5                       error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 204   5                 if(error_flag!=no_errors)
 205   5                 {
 206   6                     return_clus=no_entry_found;
 207   6                           temp8=0; 
 208   6                 }
 209   5                 i=0;
 210   5              }
 211   4              else
 212   4              {
 213   5                 temp8=0;                       // forces a function exit
 214   5              }
 215   4              }
 216   3               
 217   3          }while(temp8!=0);
 218   2        }
 219   1        else
 220   1        {
 221   2           return_clus=no_entry_found;
 222   2        }
 223   1        if(return_clus==0) return_clus=no_entry_found;
 224   1         return return_clus;
 225   1       }
 226          
 227          
 228          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1160    ----
   CONSTANT SIZE    =     13    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      39
   IDATA SIZE       =     22      17
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
